{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Proyecto 3: Predicción de precios de propiedades"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "¡Bienvenidos al tercer proyecto de la carrera de Data Science de Acamica! \n",
    "\n",
    "En este proyecto vamos a seguir trabajando con el dataset de propiedades en venta publicadas en el portal [Properati](www.properati.com.ar). El objetivo en este caso armar nuestros primeros modelos para predecir el precio de las propiedades en dólares.\n",
    "\n",
    "Las columnas que se agregan son:\n",
    "\n",
    "* `barrios_match`: si coincide el barrio publicado con el geográfico vale 1, si no 0.\n",
    "\n",
    "* `PH`, `apartment`, `house`: variables binarias que indican el tipo de propiedad.\n",
    "\n",
    "* dummies de barrios: variables binarias con 1 o 0 según el barrio.\n",
    "\n",
    "La métrica que vamos a usar para medir es RMSE (raíz del error cuadrático medio), cuya fórmula es:\n",
    "\n",
    "$$RMSE = \\sqrt{\\frac{\\sum_{t=1}^n (\\hat y_t - y_t)^2}{n}}$$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "pd.set_option('display.float_format', lambda x: '%.3f' % x)\n",
    "path_dataset = 'dataset/datos_properati_limpios_model.csv'\n",
    "df = pd.read_csv(path_dataset)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "El dataset que vamos a trabajar aquí tiene 6376 observaciones\n"
     ]
    }
   ],
   "source": [
    "print(\"El dataset que vamos a trabajar aquí tiene {} observaciones\".format(df.shape[0]))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "El objetivo de este proyecto es poder trabajar en el ajuste de modelos y su posterior evaluación."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Para empezar vamos a separar el `dataset` en un conjunto de entrenamiento (80%) y un conjunto de test (20%). \n",
    "\n",
    "**Separá el dataset** en `X_train`, `X_test`, `y_train` e `y_test` con el tamaño correspondiente"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "metadata": {},
   "outputs": [],
   "source": [
    "X = df.drop(['price_aprox_usd'], axis=1)\n",
    "y = df['price_aprox_usd']\n",
    "\n",
    "from sklearn.model_selection import train_test_split\n",
    "X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 0)\n",
    "# Realizá la separación a continuación en esta celda"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Árboles de decisión\n",
    "\n",
    "Lo primero que vamos a hacer es entrenar un árbol de decisión y usar de métrica al `RMSE`. \n",
    "\n",
    "Para poder obtener el **RMSE** vamos a medir el `mean_squared_error` y obtener su raíz cuadrada. \n",
    "\n",
    "**Importá** `DecisionTreeRegressor` desde `sklearn.tree`.  \n",
    "\n",
    "A continuación **entrená** el regresor con el conjunto de training\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "metadata": {},
   "outputs": [],
   "source": [
    "# En esta celda cargá el regresor y realizá el entrenamiento\n",
    "from sklearn.tree import DecisionTreeRegressor\n",
    "clf = DecisionTreeRegressor()\n",
    "model = clf.fit(X_train, y_train)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Con el modelo entrenado **realizá la predicción** sobre el conjunto de test `X_test` y guardá el resultado en una variable `y_pred`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Acá realizá la predicción\n",
    "y_pred = model.predict(X_test) "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Calculá el rmse** sacando la raíz cuadrada de `mean_squared_error` entre `y_test` e `y_pred` y **mostrá** el resultado"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 41,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "El valor de RMSE es de 25596.817444\n"
     ]
    }
   ],
   "source": [
    "# En esta celda calculá el rmse\n",
    "from sklearn.metrics import mean_squared_error\n",
    "from math import sqrt\n",
    "rmse = sqrt(mean_squared_error(y_test, y_pred))\n",
    "print(\"El valor de RMSE es de %f\" %(rmse))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "__Analizar el cambio en el RMSE a medida que es más profundo el árbol de decisión, tanto en training como en testing.__\n",
    "\n",
    "Para esto, **iterá** de 5 en 5 en el parámetro `max_depth` y **observá** como impacta en el RMSE. \n",
    "\n",
    "**Creá** dos arreglos `rmses_train` y `rmses_test` para ir guardando los **rmse** de cada profundidad"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 63,
   "metadata": {},
   "outputs": [],
   "source": [
    "rmses_train=[]\n",
    "rmses_test=[]\n",
    "import numpy as np\n",
    "clf = DecisionTreeRegressor(max_depth=5)\n",
    "model = clf.fit(X_train, y_train)    \n",
    "y_pred_train = model.predict(X_train)\n",
    "y_pred = model.predict(X_test)\n",
    "rmses_train = sqrt(mean_squared_error(y_train, y_pred_train))\n",
    "rmses_test = sqrt(mean_squared_error(y_test, y_pred))\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Ahora graficamos los valores que guardamos en los arreglos `rmses_train` y `rmses_test`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 64,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "ename": "ValueError",
     "evalue": "x and y must have same first dimension, but have shapes (5,) and (1,)",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mValueError\u001b[0m                                Traceback (most recent call last)",
      "\u001b[1;32m<ipython-input-64-9058b31e73a2>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m\u001b[0m\n\u001b[0;32m      1\u001b[0m \u001b[1;32mimport\u001b[0m \u001b[0mmatplotlib\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mpyplot\u001b[0m \u001b[1;32mas\u001b[0m \u001b[0mplt\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      2\u001b[0m \u001b[0mget_ipython\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mrun_line_magic\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m'matplotlib'\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;34m'inline '\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 3\u001b[1;33m \u001b[0mplt\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mplot\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mrange\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;36m5\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mrmses_train\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mlabel\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;34m'RMSE Training'\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m      4\u001b[0m \u001b[0mplt\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mplot\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mrange\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;36m5\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mrmses_test\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mlabel\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;34m'RMSE Testing'\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      5\u001b[0m \u001b[0mplt\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mylim\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;36m0\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;36m30000\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32m~\\Anaconda3\\envs\\ds\\lib\\site-packages\\matplotlib\\pyplot.py\u001b[0m in \u001b[0;36mplot\u001b[1;34m(scalex, scaley, data, *args, **kwargs)\u001b[0m\n\u001b[0;32m   2787\u001b[0m     return gca().plot(\n\u001b[0;32m   2788\u001b[0m         *args, scalex=scalex, scaley=scaley, **({\"data\": data} if data\n\u001b[1;32m-> 2789\u001b[1;33m         is not None else {}), **kwargs)\n\u001b[0m\u001b[0;32m   2790\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m   2791\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32m~\\Anaconda3\\envs\\ds\\lib\\site-packages\\matplotlib\\axes\\_axes.py\u001b[0m in \u001b[0;36mplot\u001b[1;34m(self, scalex, scaley, data, *args, **kwargs)\u001b[0m\n\u001b[0;32m   1664\u001b[0m         \"\"\"\n\u001b[0;32m   1665\u001b[0m         \u001b[0mkwargs\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mcbook\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mnormalize_kwargs\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mmlines\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mLine2D\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0m_alias_map\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m-> 1666\u001b[1;33m         \u001b[0mlines\u001b[0m \u001b[1;33m=\u001b[0m \u001b[1;33m[\u001b[0m\u001b[1;33m*\u001b[0m\u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0m_get_lines\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m*\u001b[0m\u001b[0margs\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mdata\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0mdata\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;33m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m   1667\u001b[0m         \u001b[1;32mfor\u001b[0m \u001b[0mline\u001b[0m \u001b[1;32min\u001b[0m \u001b[0mlines\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m   1668\u001b[0m             \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0madd_line\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mline\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32m~\\Anaconda3\\envs\\ds\\lib\\site-packages\\matplotlib\\axes\\_base.py\u001b[0m in \u001b[0;36m__call__\u001b[1;34m(self, *args, **kwargs)\u001b[0m\n\u001b[0;32m    223\u001b[0m                 \u001b[0mthis\u001b[0m \u001b[1;33m+=\u001b[0m \u001b[0margs\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;36m0\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m,\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    224\u001b[0m                 \u001b[0margs\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0margs\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;36m1\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 225\u001b[1;33m             \u001b[1;32myield\u001b[0m \u001b[1;32mfrom\u001b[0m \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0m_plot_args\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mthis\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mkwargs\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    226\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    227\u001b[0m     \u001b[1;32mdef\u001b[0m \u001b[0mget_next_color\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mself\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32m~\\Anaconda3\\envs\\ds\\lib\\site-packages\\matplotlib\\axes\\_base.py\u001b[0m in \u001b[0;36m_plot_args\u001b[1;34m(self, tup, kwargs)\u001b[0m\n\u001b[0;32m    389\u001b[0m             \u001b[0mx\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0my\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mindex_of\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mtup\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;33m-\u001b[0m\u001b[1;36m1\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    390\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 391\u001b[1;33m         \u001b[0mx\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0my\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0m_xy_from_xy\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mx\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0my\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    392\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    393\u001b[0m         \u001b[1;32mif\u001b[0m \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mcommand\u001b[0m \u001b[1;33m==\u001b[0m \u001b[1;34m'plot'\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32m~\\Anaconda3\\envs\\ds\\lib\\site-packages\\matplotlib\\axes\\_base.py\u001b[0m in \u001b[0;36m_xy_from_xy\u001b[1;34m(self, x, y)\u001b[0m\n\u001b[0;32m    268\u001b[0m         \u001b[1;32mif\u001b[0m \u001b[0mx\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mshape\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;36m0\u001b[0m\u001b[1;33m]\u001b[0m \u001b[1;33m!=\u001b[0m \u001b[0my\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mshape\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;36m0\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    269\u001b[0m             raise ValueError(\"x and y must have same first dimension, but \"\n\u001b[1;32m--> 270\u001b[1;33m                              \"have shapes {} and {}\".format(x.shape, y.shape))\n\u001b[0m\u001b[0;32m    271\u001b[0m         \u001b[1;32mif\u001b[0m \u001b[0mx\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mndim\u001b[0m \u001b[1;33m>\u001b[0m \u001b[1;36m2\u001b[0m \u001b[1;32mor\u001b[0m \u001b[0my\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mndim\u001b[0m \u001b[1;33m>\u001b[0m \u001b[1;36m2\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    272\u001b[0m             raise ValueError(\"x and y can be no greater than 2-D, but have \"\n",
      "\u001b[1;31mValueError\u001b[0m: x and y must have same first dimension, but have shapes (5,) and (1,)"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "%matplotlib inline \n",
    "plt.plot(range(1,30, 5), rmses_train, label='RMSE Training')\n",
    "plt.plot(range(1,30, 5), rmses_test, label='RMSE Testing')\n",
    "plt.ylim((0, 30000))\n",
    "plt.legend(loc=\"best\")\n",
    "plt.title(\"RMSE Training vs RMSE Testing para árboles de decisión\")\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Podemos ver aquí como el modelo presenta sobreajuste dado que a mayor complejidad (en este caso, mayor profundidad del árbol) más diferencia entre los resultados de training y testing. También observamos como la curva de testing decrece y luego vuelvo a crecer. El punto donde se minimiza está relacionado con el tradeoff entre sesgo y varianza que vamos a ver en la próxima unidad."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## KNN"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Entrená un knn** y nuevamente medir el **rmse** en el conjunto de testing\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 44,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "El valor de RMSE es de 25613.944017\n"
     ]
    }
   ],
   "source": [
    "# Realizá el entrenamiento y el cálculo de rmse en esta celda\n",
    "from sklearn.neighbors import KNeighborsRegressor\n",
    "knr = KNeighborsRegressor()\n",
    "knr.fit(X_train, y_train) \n",
    "y_pred = model.predict(X_test)\n",
    "rmse = sqrt(mean_squared_error(y_test, y_pred))\n",
    "print(\"El valor de RMSE es de %f\" %(rmse))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "__Analizar el cambio en el RMSE a medida que consideramos más vecinos para KNN, tanto en training como en testing.__\n",
    "\n",
    "Para esto, **iterá** incrementando de a uno el parámetro `n_neighbors` y **observá** como impacta en el RMSE. \n",
    "\n",
    "**Creá** dos arreglos `rmses_train` y `rmses_test` para ir guardando los **rmse** de cada profundidad"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 45,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Calculá los cambios en el rmse en esta celda\n",
    "rmses_train=[]\n",
    "rmses_test=[]\n",
    "for i in np.arange(1,30,1):\n",
    "    clf = KNeighborsRegressor(n_neighbors=i)\n",
    "    model = clf.fit(X_train, y_train)    \n",
    "    y_pred_train = model.predict(X_train)\n",
    "    y_pred = model.predict(X_test)\n",
    "    rmses_train.append(sqrt(mean_squared_error(y_train, y_pred_train)))\n",
    "    rmses_test.append(sqrt(mean_squared_error(y_test, y_pred)))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 46,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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OTn7P0wt0j6zG+I15agfwacvwLrnYNK5Lec3xphuYtasWZSWlhIMBrnuuusiBoS2it2gMOp46H+oO+FsQcEY04O89dZbnbbu2DynAO6ahby5kP8eFH4U7dIYY0y3ELtBASD3fEhIhffvazmvMcbEgNgOCql94cjvwponoKI42qUxxpioi+2gAO6Ec3AffLSo5bzGGNPLWVAYOhmGTYWV90EPHZ5rTKzoybfOBnj66af59NNP6z635nbaXS12Rx+FO+pH8OyPYdNbMOrr0S6NMaYJ3f3W2S15+umniYuL44gjjgBadzvtrmYtBYDxZ7nzC+/fG+2SGGNaqTvcOhvgxRdf5Oijj2bKlCmce+657N27F4Arr7yScePGMXHiRH75y1/y1ltvsXTpUq644oq6VkZrbqddVFTESSedxJQpU7jssssYNmxYXQupM1hLASAxFSZ/H975C5QWQuaQaJfImO7txatg25qW8x2IwUfCrBtblbW73Dq7qKiIG2+8kWXLltGnTx9+//vf8+c//5m5c+eydOlS1q5di4hQXFxMdnY2p556KmeffTZnnnlmxPVFup32b37zG2bOnMmVV17JCy+8wJ133tmqv1FbWUshJO9i0Br48MFol8QY04Tuduvsf/3rX6xbt45jjjmG3NxcHnnkETZt2kS/fv2Ii4vjkksu4ZlnniEtLa1V64t0O+23336b8847D4DTTjuNjIyMVq2rraylENLvEDj0m+6pbMf9HOITo10iY7qvVh7Rd7TudutsVWXmzJk8/PDD+81buXIlr776KosWLeLOO+/klVdeaXF9kW6n3dX3p7OWQrijfgRlhbBhabRLYoxpRne5dfYxxxzDG2+8wZdffgnA3r17+fzzzykrK6O0tJTTTjuNP/7xj6xatQqAjIwMysrKDug7jj32WBYvXgzA0qVLD3j5A2VBIdyYkyFrhJ1wNqYH6A63zh40aBD33Xcf5557LpMmTeKYY47hs88+o6SkhG9/+9tMmjSJE088kdtuuw2A888/nxtuuOGAhrNed911/P3vf2fKlCn84x//YNCgQa3ujmoTVW12AkYArwPrgbXA5T79WmArsNpPp4Yt8ytgI7ABOCUsfaZP2whcFZY+ClgBfA48DiS1VK6pU6dqp3jzD6oLM1WLPu2c9RvTQ61bty7aRYhJFRUVGgwGVVX1rbfe0gOp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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.plot(range(1,30, 1), rmses_train, label='RMSE Training')\n",
    "plt.plot(range(1,30, 1), rmses_test, label='RMSE Testing')\n",
    "plt.ylim((0, 30000))\n",
    "plt.legend(loc=\"best\")\n",
    "plt.title(\"RMSE Training vs RMSE Testing para KNN\")\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Calcular el RMSE promedio del resultado de cross validation para un árbol de decisión. \n",
    "Como parámetros deberás usar:**\n",
    "- 10 folds\n",
    "- profundidad 5\n",
    "- scoring neg_mean_squared_error.\n",
    "\n",
    "El árbol de decisión guardalo en una variable llamada `regressor` para poder reutilizarla luego.\n",
    "\n",
    "Atención: `cross_validation_score` de `scikit-learn` usá la métrica `neg_mean_squared_error` (NMSE) en vez de `mean_square_error` (MSE). \n",
    "\n",
    "`NMSE` es lo mismo que `MSE` pero con un signo negativo. \n",
    "\n",
    "Como nosotros queremos obtener el `MSE` para calcular sobre él el `RMSE`, vamos a definir un método `nmsq2rmse` para hacer esa conversión de `NMSE` a `MSE`\n",
    "."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 47,
   "metadata": {},
   "outputs": [],
   "source": [
    "def nmsq2rmse(score):\n",
    "    return np.sqrt(-score)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 48,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "El valor de RMSE promedio de cross validation para árbol de decisión es de 22041.698266\n"
     ]
    }
   ],
   "source": [
    "# Calculá en esta celda los cross_val_score\n",
    "from sklearn.model_selection import cross_val_score\n",
    "regressor = DecisionTreeRegressor(max_depth=5)\n",
    "neg_scores = cross_val_score(regressor, X_train, y_train,scoring=\"neg_mean_squared_error\", cv=10)\n",
    "scores = np.array([nmsq2rmse(s) for s in neg_scores])\n",
    "rmse_medio = scores.mean()\n",
    "print(\"El valor de RMSE promedio de cross validation para árbol de decisión es de %f\" %(rmse_medio))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Para ver el resultado final, reentrenamos al regresor y mostramos en un dataframe la comparación entre los valores reales, los predichos y su diferencia"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 49,
   "metadata": {},
   "outputs": [],
   "source": [
    "regressor.fit(X_train, y_train)\n",
    "y_pred = regressor.predict(X_test)\n",
    "val_real = pd.Series(y_test.values)\n",
    "val_pred = pd.Series(y_pred)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 50,
   "metadata": {},
   "outputs": [],
   "source": [
    "predicciones = pd.concat([val_real.rename('Valor real'),val_pred.rename('Valor Pred') ,abs(val_real-val_pred).rename('Dif(+/-)')] ,  axis=1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 51,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>Valor real</th>\n",
       "      <th>Valor Pred</th>\n",
       "      <th>Dif(+/-)</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>148000.000</td>\n",
       "      <td>116171.142</td>\n",
       "      <td>31828.858</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>88000.000</td>\n",
       "      <td>133983.146</td>\n",
       "      <td>45983.146</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>165000.000</td>\n",
       "      <td>133983.146</td>\n",
       "      <td>31016.854</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>113000.000</td>\n",
       "      <td>128719.494</td>\n",
       "      <td>15719.494</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>140000.000</td>\n",
       "      <td>146638.938</td>\n",
       "      <td>6638.938</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>5</th>\n",
       "      <td>80000.000</td>\n",
       "      <td>74416.134</td>\n",
       "      <td>5583.866</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>6</th>\n",
       "      <td>105000.000</td>\n",
       "      <td>118004.123</td>\n",
       "      <td>13004.123</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>7</th>\n",
       "      <td>137000.000</td>\n",
       "      <td>118004.123</td>\n",
       "      <td>18995.877</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>8</th>\n",
       "      <td>115000.000</td>\n",
       "      <td>133983.146</td>\n",
       "      <td>18983.146</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>9</th>\n",
       "      <td>80000.000</td>\n",
       "      <td>77728.837</td>\n",
       "      <td>2271.163</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "   Valor real  Valor Pred  Dif(+/-)\n",
       "0  148000.000  116171.142 31828.858\n",
       "1   88000.000  133983.146 45983.146\n",
       "2  165000.000  133983.146 31016.854\n",
       "3  113000.000  128719.494 15719.494\n",
       "4  140000.000  146638.938  6638.938\n",
       "5   80000.000   74416.134  5583.866\n",
       "6  105000.000  118004.123 13004.123\n",
       "7  137000.000  118004.123 18995.877\n",
       "8  115000.000  133983.146 18983.146\n",
       "9   80000.000   77728.837  2271.163"
      ]
     },
     "execution_count": 51,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "predicciones.head(10)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
